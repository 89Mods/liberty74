/* Copyright 2023 Tobias Senti                                        */
/* Solderpad Hardware License, Version 0.51, see LICENSE for details. */
/* SPDX-License-Identifier: SHL-0.51                                  */

/* ${stamp} */

library(${lib_name}) {
  delay_model : table_lookup;

  /* Units */
  time_unit               : "1ns";
  voltage_unit            : "1V";
  current_unit            : "1mA";
  capacitive_load_unit(1,pf);
  leakage_power_unit      : "1mW";
  pulling_resistance_unit : "1kohm";

  /* Operating Conditions */
  operating_conditions (${lib_name}) {
    process_corner	: "${corner["process_name"]}";
    process       	: 1.00;
    voltage       	: ${corner["voltage"]};
    temperature   	: ${corner["temperature"]};
    tree_type     	: balanced_tree;
  }

  default_operating_conditions : ${lib_name};
  nom_process     : 1.00;
  nom_temperature : ${corner["temperature"]};
  nom_voltage     : ${corner["voltage"]};

  voltage_map (VDD, ${corner["voltage"]});
  voltage_map (GND, 0.0);

  /* Threshold Definitions */
  slew_lower_threshold_pct_fall 	: 20.00 ;
  slew_lower_threshold_pct_rise 	: 20.00 ;
  slew_upper_threshold_pct_fall 	: 80.00 ;
  slew_upper_threshold_pct_rise 	: 80.00 ;
  slew_derate_from_library      	: 1.00 ;
  input_threshold_pct_fall      	: 50.00 ;
  input_threshold_pct_rise      	: 50.00 ;
  output_threshold_pct_fall     	: 50.00 ;
  output_threshold_pct_rise     	: 50.00 ;
  default_leakage_power_density 	: 0.00 ;
  default_cell_leakage_power    	: 0.00 ;

  default_input_pin_cap       		: 5.000000;
  default_inout_pin_cap       		: 5.000000;
  default_output_pin_cap      		: 0.000000;
  default_max_capacitance         : ${corner["default_max_cap"]};
  default_max_transition          : 25;
  default_max_fanout              : 8;
  default_fanout_load             : 1;

  inplace_swap_mode : match_footprint;

% for type in bus_types:
  type (${type}) {
    base_type : array;
    data_type : bit;
    bit_width : ${bus_types[type]["width"]};
    bit_from  : ${bus_types[type]["from"]};
    bit_to    : ${bus_types[type]["to"]};
  % if bus_types[type]["from"] > bus_types[type]["to"]:
    downto    : true;
  % else:
    downto    : false;
  % endif
  }

% endfor
% for cell in cells:
  cell (${cell["name"]}) {
    /* ${cell["desc"]} */
  % if "tapcell" in cell and cell["tapcell"]:
    is_tap_cell: true;
  % endif
    area: ${footprints[cell["footprint"]]["cell_width"] * footprints[cell["footprint"]]["cell_height"]};
  % if "ff" in cell:
    ff ("IQ", "IQN") {
      clocked_on: ${cell["ff"]["clocked_on"]};
      next_state: ${cell["ff"]["next_state"]};
    % if "clear" in cell["ff"]:
      clear: "${cell["ff"]["clear"]}";
    % endif
    }
  % endif
  % if 'power' in cell:
    % for power in cell["power"]:
    pg_pin (${power["name"]}) {
      % if "connect_to_net" in power:
      voltage_name: "${power["connect_to_net"]}";
      % else:
      voltage_name: "${power["name"]}";
      % endif
      pg_type: primary_${power["function"]};
    }
    % endfor
  % endif
  % if 'inputs' in cell:
    % for input in cell["inputs"]:
      % if "bus_name" in input:
    bus (${input["bus_name"]}) {
      bus_type: ${input['bus_type']};
      direction: input;
      capacitance: ${corner["default_input_cap"]};
    }
      % else:
    pin (${input["name"]}) {
      direction: input;
      capacitance: ${corner["default_input_cap"]};
        % if "clock" in input and input["clock"]:
      clock: true;
        % endif
        % if "timing" in input:

          % for timing in input["timing"]:
      timing () {
        related_pin: "${timing["related_pin"]}";
            % if "setup_time" in timing:
        timing_type: setup_rising;

        rise_constraint(scalar) {
          values ("${timing["setup_time"][corner["name"]]}");
        }
        fall_constraint(scalar) {
          values ("${timing["setup_time"][corner["name"]]}");
        }
            % endif
            % if "hold_time" in timing:
        timing_type: hold_rising;

        rise_constraint(scalar) {
          values ("${timing["hold_time"][corner["name"]]}");
        }
        fall_constraint(scalar) {
          values ("${timing["hold_time"][corner["name"]]}");
        }
            % endif
      }
          % endfor
        % endif
    }
      % endif
    % endfor
  % endif
  % if 'inouts' in cell:
    % for inout in cell["inouts"]:
      % if "bus_name" in inout:
    bus (${inout["bus_name"]}) {
      bus_type: ${inout['bus_type']};
      direction: inout;
      % if 'default_inout_cap' in corner:
      capacitance: ${corner["default_inout_cap"]};
      % else:
      capacitance: ${corner["default_input_cap"]};
      % endif
      max_capacitance: ${corner["default_max_cap"]};
      three_state: "${inout["three_state"]}";
    }
      % else:
    pin (${inout["name"]}) {
      direction: inout;
      function: "${inout["function"]}";
      three_state: "${inout["three_state"]}";
      % if 'default_inout_cap' in corner:
      capacitance: ${corner["default_inout_cap"]};
      % else:
      capacitance: ${corner["default_input_cap"]};
      % endif
      max_capacitance: ${corner["default_max_cap"]};

        % if "timing" in inout:
          % for timing in inout["timing"]:
      timing () {
        related_pin: "${timing["related_pin"]}";
        timing_sense: ${timing["timing_sense"]};
        timing_type: ${timing["timing_type"]};

            % if "delays_rise_fall" in timing:
        cell_rise(scalar) {
          values ("${timing["delays_rise_fall"][corner["name"]]}");
        }
        cell_fall(scalar) {
          values ("${timing["delays_rise_fall"][corner["name"]]}");
        }
        rise_transition(scalar) {
          values ("0.001");
        }
        fall_transition(scalar) {
          values ("0.001");
        }
            % else:
        cell_fall(scalar) {
          values ("${timing["delays_fall"][corner["name"]]}");
        }
        fall_transition(scalar) {
          values ("0.001");
        }
            % endif
      }
          % endfor
        % endif
    }
      % endif
    % endfor
  % endif
  % if 'outputs' in cell:
    % for output in cell["outputs"]:
      % if "bus_name" in output:
    bus (${output["bus_name"]}) {
      bus_type: ${output['bus_type']};
      direction: output;
      capacitance: ${corner["default_input_cap"]};
    }
      % else:
    pin (${output["name"]}) {
      direction: output;
      function: "${output["function"]}";
      max_capacitance: ${corner["default_max_cap"]};

        % if "timing" in output:
          % for timing in output["timing"]:
      timing () {
        related_pin: "${timing["related_pin"]}";
        timing_sense: ${timing["timing_sense"]};
        timing_type: ${timing["timing_type"]};

            % if "delays_rise_fall" in timing:
        cell_rise(scalar) {
          values ("${timing["delays_rise_fall"][corner["name"]]}");
        }
        cell_fall(scalar) {
          values ("${timing["delays_rise_fall"][corner["name"]]}");
        }
        rise_transition(scalar) {
          values ("0.001");
        }
        fall_transition(scalar) {
          values ("0.001");
        }
            % else:
        cell_fall(scalar) {
          values ("${timing["delays_fall"][corner["name"]]}");
        }
        fall_transition(scalar) {
          values ("0.001");
        }
            % endif
      }
          % endfor
        % endif
    }
      % endif
    % endfor
  % endif
  }
% endfor
}
